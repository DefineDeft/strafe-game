<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STRAFE - Arena</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        #gameContainer {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            position: relative;
        }
        
        canvas {
            border: 3px solid rgba(0, 245, 255, 0.5);
            box-shadow: 0 0 60px rgba(0, 245, 255, 0.3);
            border-radius: 10px;
        }
        
        #connectionStatus {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            color: #00f5ff;
            padding: 12px 20px;
            border-radius: 10px;
            font-size: 14px;
            font-weight: bold;
            z-index: 1000;
            border: 2px solid rgba(0, 245, 255, 0.3);
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.2);
        }
        
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 9999;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        #loadingScreen h2 {
            font-size: 72px;
            font-weight: 900;
            letter-spacing: -2px;
            background: linear-gradient(45deg, #00f5ff, #ff00ff, #ffaa00);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradient 3s ease infinite;
            margin-bottom: 20px;
        }
        
        @keyframes gradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        #loadingScreen p {
            font-size: 18px;
            opacity: 0.9;
        }
        
        #loadingScreen.hidden {
            display: none;
        }
        
        .status-good { 
            background: rgba(0, 245, 80, 0.2) !important;
            border-color: rgba(0, 245, 80, 0.5) !important;
            color: #00f550 !important;
        }
        .status-warning { 
            background: rgba(255, 170, 0, 0.2) !important;
            border-color: rgba(255, 170, 0, 0.5) !important;
            color: #ffaa00 !important;
        }
        .status-bad { 
            background: rgba(255, 0, 110, 0.2) !important;
            border-color: rgba(255, 0, 110, 0.5) !important;
            color: #ff006e !important;
        }
        
        #backButton {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 12px 24px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 0, 255, 0.3);
            border-radius: 10px;
            color: #ff00ff;
            text-decoration: none;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
            z-index: 1000;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.2);
        }
        
        #backButton:hover {
            background: rgba(255, 0, 255, 0.2);
            border-color: rgba(255, 0, 255, 0.6);
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.4);
            transform: translateY(-2px);
        }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <h2>STRAFE</h2>
        <p>Connecting to server...</p>
        <p style="font-size: 14px; color: rgba(255,255,255,0.6); margin-top: 10px;">Server may be waking up (30-60s)</p>
    </div>
    
    <div id="gameContainer">
        <a href="/" id="backButton">‚Üê BACK TO MENU</a>
        <div id="connectionStatus">Connecting...</div>
        <canvas id="gameCanvas"></canvas>
    </div>
    
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = 1200;
        canvas.height = 800;
        
        // Particle system for visual effects
        const particles = [];
        
        // ==================== GAME STATE ====================
        const game = {
            myId: null,
            config: null,
            connected: false,
            player: null,
            otherPlayers: {},
            bullets: {},
            money: {},
            inputSequence: 0,
            camera: { x: 0, y: 0 },
            ping: 0,
            fps: 60,
            serverTick: 0,
            mouse: { x: 0, y: 0 },
            charging: { active: false, startTime: 0 }
        };
        
        let lastFrameTime = performance.now();
        let frameCount = 0;
        let lastFpsUpdate = performance.now();
        
        // ==================== PARTICLE EFFECTS ====================
        class Particle {
            constructor(x, y, color, size = 3, vx = 0, vy = 0, lifetime = 1000) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = size;
                this.vx = vx;
                this.vy = vy;
                this.lifetime = lifetime;
                this.createdAt = Date.now();
                this.alpha = 1;
            }
            
            update(deltaTime) {
                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;
                
                const age = Date.now() - this.createdAt;
                this.alpha = 1 - (age / this.lifetime);
                
                return age < this.lifetime;
            }
            
            draw(camera) {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.arc(this.x - camera.x, this.y - camera.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        
        function createHitEffect(x, y, color) {
            for (let i = 0; i < 12; i++) {
                const angle = (Math.PI * 2 * i) / 12;
                const speed = 2 + Math.random() * 2;
                particles.push(new Particle(
                    x, y, color, 4,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    500
                ));
            }
        }
        
        function createBoostTrail(x, y, angle) {
            const offsetAngle = angle + Math.PI;
            const distance = 25;
            const px = x + Math.cos(offsetAngle) * distance;
            const py = y + Math.sin(offsetAngle) * distance;
            
            particles.push(new Particle(
                px, py,
                'rgba(0, 245, 255, 0.8)',
                3 + Math.random() * 2,
                Math.cos(offsetAngle) * 0.5,
                Math.sin(offsetAngle) * 0.5,
                300
            ));
        }
        
        // ==================== SOCKET CONNECTION ====================
        const socket = io({
            reconnection: true,
            reconnectionDelay: 1000,
            reconnectionDelayMax: 5000,
            reconnectionAttempts: 5
        });
        
        socket.on('connect', () => {
            console.log('Connected to server');
            game.connected = true;
            updateConnectionStatus('Connected', 'status-good');
        });
        
        socket.on('disconnect', () => {
            console.log('Disconnected from server');
            game.connected = false;
            updateConnectionStatus('Disconnected - Reconnecting...', 'status-bad');
            document.getElementById('loadingScreen').classList.remove('hidden');
        });
        
        socket.on('init', (data) => {
            console.log('Received init data:', data);
            game.myId = data.playerId;
            game.config = data.config;
            
            const myData = data.gameState.players[game.myId];
            game.player = { ...myData, velocityX: 0, velocityY: 0 };
            
            Object.values(data.gameState.players).forEach(p => {
                if (p.id !== game.myId) {
                    game.otherPlayers[p.id] = { ...p, renderX: p.x, renderY: p.y };
                }
            });
            
            data.gameState.bullets.forEach(b => {
                game.bullets[b.id] = { ...b, renderX: b.x, renderY: b.y };
            });
            
            data.gameState.money.forEach(m => {
                game.money[m.id] = m;
            });
            
            document.getElementById('loadingScreen').classList.add('hidden');
            updateConnectionStatus(`Connected | Players: ${Object.keys(data.gameState.players).length}`, 'status-good');
        });
        
        socket.on('gameState', (snapshot) => {
            game.serverTick = snapshot.tick;
            
            snapshot.players.forEach(serverPlayer => {
                if (serverPlayer.id === game.myId) {
                    // Calculate prediction error
                    const errorX = serverPlayer.x - game.player.x;
                    const errorY = serverPlayer.y - game.player.y;
                    const errorDist = Math.hypot(errorX, errorY);
                    
                    // Tiered reconciliation based on error size
                    if (errorDist < 5) {
                        // Tiny error - very gentle correction
                        game.player.x += errorX * 0.1;
                        game.player.y += errorY * 0.1;
                    } else if (errorDist < 15) {
                        // Small error - normal correction
                        game.player.x += errorX * 0.3;
                        game.player.y += errorY * 0.3;
                    } else if (errorDist < 40) {
                        // Medium error - faster correction
                        game.player.x += errorX * 0.6;
                        game.player.y += errorY * 0.6;
                    } else {
                        // Big error (>40px = player width) - snap to server
                        console.warn(`Large position error: ${errorDist.toFixed(1)}px - snapping to server`);
                        game.player.x = serverPlayer.x;
                        game.player.y = serverPlayer.y;
                        game.player.velocityX = serverPlayer.velocityX;
                        game.player.velocityY = serverPlayer.velocityY;
                    }
                    
                    // Always trust server for these
                    game.player.energy = serverPlayer.energy;
                    game.player.dollarValue = serverPlayer.dollarValue;
                    game.player.invulnerable = serverPlayer.invulnerable;
                    game.player.invulnerableTicksRemaining = serverPlayer.invulnerableTicksRemaining;
                    game.player.killStreak = serverPlayer.killStreak;
                    game.player.bountyMultiplier = serverPlayer.bountyMultiplier;
                } else {
                    if (!game.otherPlayers[serverPlayer.id]) {
                        game.otherPlayers[serverPlayer.id] = {
                            ...serverPlayer,
                            renderX: serverPlayer.x,
                            renderY: serverPlayer.y
                        };
                    } else {
                        const player = game.otherPlayers[serverPlayer.id];
                        Object.assign(player, serverPlayer);
                        if (player.renderX === undefined) {
                            player.renderX = player.x;
                            player.renderY = player.y;
                        }
                    }
                }
            });
            
            Object.keys(game.otherPlayers).forEach(id => {
                if (!snapshot.players.find(p => p.id === id)) {
                    delete game.otherPlayers[id];
                }
            });
            
            const newBullets = {};
            snapshot.bullets.forEach(b => {
                if (game.bullets[b.id]) {
                    // Update existing bullet from server
                    const bullet = game.bullets[b.id];
                    
                    // Gently correct renderX/renderY if they've drifted from server
                    const errorX = b.x - bullet.renderX;
                    const errorY = b.y - bullet.renderY;
                    const errorDist = Math.hypot(errorX, errorY);
                    
                    // If error is small, smoothly correct. If large, snap.
                    if (errorDist < 20) {
                        bullet.renderX += errorX * 0.3;
                        bullet.renderY += errorY * 0.3;
                    } else {
                        // Large error - snap to server position
                        bullet.renderX = b.x;
                        bullet.renderY = b.y;
                    }
                    
                    // Always trust server for actual position and velocity
                    bullet.x = b.x;
                    bullet.y = b.y;
                    bullet.vx = b.vx;
                    bullet.vy = b.vy;
                    newBullets[b.id] = bullet;
                } else {
                    // New bullet from server - initialize with current position
                    newBullets[b.id] = {
                        ...b,
                        renderX: b.x,
                        renderY: b.y
                    };
                }
            });
            
            // Remove predicted bullets when server version arrives or they're old
            Object.keys(game.bullets).forEach(id => {
                const bullet = game.bullets[id];
                if (bullet.isPredicted) {
                    // Check if server has confirmed this bullet (same owner, similar position)
                    const serverConfirmed = snapshot.bullets.some(sb => 
                        sb.ownerId === bullet.ownerId && 
                        Math.hypot(sb.x - bullet.x, sb.y - bullet.y) < 50
                    );
                    if (!serverConfirmed && Date.now() - parseInt(id.split('_')[2]) < 200) {
                        // Keep predicted bullet for a bit if not confirmed yet
                        newBullets[id] = bullet;
                    }
                    // Otherwise discard the predicted bullet
                } else if (snapshot.bullets.find(b => b.id === id)) {
                    // Keep non-predicted bullets that still exist on server
                    if (!newBullets[id]) {
                        newBullets[id] = game.bullets[id];
                    }
                }
            });
            
            game.bullets = newBullets;
            
            game.money = {};
            snapshot.money.forEach(m => {
                game.money[m.id] = m;
            });
            
            updateConnectionStatus(
                `Players: ${snapshot.players.length} | ${game.ping}ms`, 
                game.ping < 100 ? 'status-good' : game.ping < 200 ? 'status-warning' : 'status-bad'
            );
        });
        
        socket.on('bulletSpawned', (bullet) => {
            game.bullets[bullet.id] = {
                ...bullet,
                renderX: bullet.x,
                renderY: bullet.y
            };
        });
        
        socket.on('bulletRemoved', (bulletId) => {
            delete game.bullets[bulletId];
        });
        
        socket.on('playerHit', (data) => {
            if (data.targetId === game.myId) {
                game.player.energy = data.energy;
                if (game.player) {
                    createHitEffect(game.player.x, game.player.y, '#ff006e');
                }
            } else if (game.otherPlayers[data.targetId]) {
                game.otherPlayers[data.targetId].energy = data.energy;
                const target = game.otherPlayers[data.targetId];
                createHitEffect(target.x, target.y, '#ff006e');
            }
        });
        
        socket.on('playerDied', (data) => {
            if (data.playerId === game.myId) {
                game.player.x = data.respawn.x;
                game.player.y = data.respawn.y;
                game.player.velocityX = 0;
                game.player.velocityY = 0;
                game.player.energy = data.respawn.energy;
                game.player.dollarValue = data.respawn.dollarValue;
                game.player.invulnerable = true;
                game.player.invulnerableTicksRemaining = data.respawn.invulnerableTicksRemaining;
                game.player.killStreak = 0;
                game.player.bountyMultiplier = 1.0;
            }
            
            if (data.moneyDrop) {
                game.money[data.moneyDrop.id] = data.moneyDrop;
                createHitEffect(data.moneyDrop.x, data.moneyDrop.y, '#FFD700');
            }
        });
        
        socket.on('moneyPickedUp', (data) => {
            const money = game.money[data.moneyId];
            if (money) {
                createHitEffect(money.x, money.y, '#FFD700');
            }
            delete game.money[data.moneyId];
            
            if (data.playerId === game.myId) {
                game.player.dollarValue = data.newDollarValue;
            }
        });
        
        socket.on('playerJoined', (player) => {
            if (player.id !== game.myId) {
                game.otherPlayers[player.id] = {
                    ...player,
                    renderX: player.x,
                    renderY: player.y
                };
            }
        });
        
        socket.on('playerLeft', (playerId) => {
            delete game.otherPlayers[playerId];
        });
        
        socket.on('pong', (timestamp) => {
            game.ping = Date.now() - timestamp;
        });
        
        setInterval(() => {
            if (game.connected) {
                socket.emit('ping', Date.now());
            }
        }, 2000);
        
        function updateConnectionStatus(text, className) {
            const status = document.getElementById('connectionStatus');
            status.textContent = text;
            status.className = className;
        }
        
        // ==================== INPUT HANDLING ====================
        const keys = {};
        
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            game.mouse.x = e.clientX - rect.left;
            game.mouse.y = e.clientY - rect.top;
        });
        
        canvas.addEventListener('mousedown', () => {
            if (!game.player || !game.connected) return;
            game.charging.active = true;
            game.charging.startTime = Date.now();
            shoot(0);
        });
        
        canvas.addEventListener('mouseup', () => {
            if (!game.player || !game.connected || !game.charging.active) return;
            
            const chargeTime = Date.now() - game.charging.startTime;
            let chargeLevel = 0;
            
            if (chargeTime >= 1000) chargeLevel = 2;
            else if (chargeTime >= 500) chargeLevel = 1;
            
            if (chargeLevel > 0) {
                shoot(chargeLevel);
            }
            
            game.charging.active = false;
        });
        
        function shoot(chargeLevel) {
            if (!game.player || !game.config) return;
            
            const bulletTypes = game.config.BULLET.TYPES;
            let bulletType;
            
            switch(chargeLevel) {
                case 1: bulletType = bulletTypes.CHARGED1; break;
                case 2: bulletType = bulletTypes.CHARGED2; break;
                default: bulletType = bulletTypes.NORMAL;
            }
            
            if (game.player.energy < bulletType.energyCost) return;
            
            game.player.energy -= bulletType.energyCost;
            
            // CLIENT-SIDE PREDICTION: Spawn bullet locally immediately
            const barrelLength = 35; // Match the visual barrel length
            const predictedBullet = {
                id: `predicted_${game.myId}_${Date.now()}_${Math.random()}`,
                x: game.player.x + Math.cos(game.player.angle) * barrelLength,
                y: game.player.y + Math.sin(game.player.angle) * barrelLength,
                vx: Math.cos(game.player.angle) * bulletType.speed,
                vy: Math.sin(game.player.angle) * bulletType.speed,
                radius: bulletType.radius,
                damage: bulletType.damage,
                ownerId: game.myId,
                chargeLevel: chargeLevel,
                renderX: game.player.x + Math.cos(game.player.angle) * barrelLength,
                renderY: game.player.y + Math.sin(game.player.angle) * barrelLength,
                isPredicted: true
            };
            
            game.bullets[predictedBullet.id] = predictedBullet;
            
            socket.emit('shoot', { chargeLevel: chargeLevel });
        }
        
        function getChargeLevel() {
            if (!game.charging.active) return 0;
            const chargeTime = Date.now() - game.charging.startTime;
            if (chargeTime >= 1000) return 2;
            if (chargeTime >= 500) return 1;
            return 0;
        }
        
        // ==================== CLIENT PREDICTION (FIXED TIMESTEP) ====================
        function processInput(deltaTime) {
            if (!game.player || !game.connected) return;
            
            const input = {
                sequence: game.inputSequence++,
                up: keys['w'] || keys['arrowup'],
                down: keys['s'] || keys['arrowdown'],
                left: keys['a'] || keys['arrowleft'],
                right: keys['d'] || keys['arrowright'],
                boost: keys[' '],
                angle: Math.atan2(
                    game.mouse.y - (game.player.y - game.camera.y),
                    game.mouse.x - (game.player.x - game.camera.x)
                )
            };
            
            socket.emit('input', input);
            applyInput(game.player, input, deltaTime);
            
            // Boost trail effect
            if (input.boost && game.player.energy > 0) {
                if (Math.random() < 0.3) {
                    createBoostTrail(game.player.x, game.player.y, game.player.angle);
                }
            }
        }
        
        // FIXED: Added deltaTime parameter properly
        function applyInput(player, input, deltaTime) {
            if (!game.config) return;
            
            let inputX = 0;
            let inputY = 0;
            
            if (input.up) inputY -= 1;
            if (input.down) inputY += 1;
            if (input.left) inputX -= 1;
            if (input.right) inputX += 1;
            
            // Normalize diagonal movement
            if (inputX !== 0 && inputY !== 0) {
                const length = Math.hypot(inputX, inputY);
                inputX /= length;
                inputY /= length;
            }
            
            // Apply acceleration
            const accel = game.config.PLAYER.ACCELERATION * deltaTime;
            player.velocityX += inputX * accel;
            player.velocityY += inputY * accel;
            
            // Apply momentum/friction
            const momentum = Math.pow(game.config.PLAYER.MOMENTUM, deltaTime);
            player.velocityX *= momentum;
            player.velocityY *= momentum;
            
            // Handle boost
            const isBoosting = input.boost && player.energy > 0;
            if (isBoosting) {
                player.energy = Math.max(0, player.energy - game.config.PLAYER.ENERGY.BOOST_DRAIN * deltaTime);
            } else {
                player.energy = Math.min(
                    game.config.PLAYER.ENERGY.MAX,
                    player.energy + game.config.PLAYER.ENERGY.REGEN * deltaTime
                );
            }
            
            // Cap velocity
            const maxVel = isBoosting ? game.config.PLAYER.MAX_BOOST_VELOCITY : game.config.PLAYER.MAX_VELOCITY;
            const speed = Math.hypot(player.velocityX, player.velocityY);
            if (speed > maxVel) {
                player.velocityX = (player.velocityX / speed) * maxVel;
                player.velocityY = (player.velocityY / speed) * maxVel;
            }
            
            // Update position
            player.x += player.velocityX * deltaTime;
            player.y += player.velocityY * deltaTime;
            player.angle = input.angle;
        }
        
        // ==================== INTERPOLATION ====================
        function interpolateEntities(alpha) {
            const lerpFactor = 0.2;
            
            // Only interpolate other players (they have unpredictable movement)
            Object.values(game.otherPlayers).forEach(player => {
                player.renderX += (player.x - player.renderX) * lerpFactor;
                player.renderY += (player.y - player.renderY) * lerpFactor;
            });
            
            // Bullets are extrapolated in updatePredictedBullets, not interpolated
        }
        
        function updateParticles(deltaTime) {
            for (let i = particles.length - 1; i >= 0; i--) {
                if (!particles[i].update(deltaTime)) {
                    particles.splice(i, 1);
                }
            }
        }
        
        function updatePredictedBullets(deltaTime) {
            // Move ALL bullets on client using their velocity (extrapolation)
            Object.values(game.bullets).forEach(bullet => {
                if (bullet.vx !== undefined && bullet.vy !== undefined) {
                    // Extrapolate bullet position every frame at constant velocity
                    bullet.renderX += bullet.vx * deltaTime;
                    bullet.renderY += bullet.vy * deltaTime;
                    
                    // For predicted bullets, also update actual position
                    if (bullet.isPredicted) {
                        bullet.x += bullet.vx * deltaTime;
                        bullet.y += bullet.vy * deltaTime;
                    }
                }
            });
        }
        
        // ==================== RENDERING ====================
        function updateCamera() {
            if (!game.player || !game.config) return;
            
            game.camera.x = game.player.x - canvas.width / 2;
            game.camera.y = game.player.y - canvas.height / 2;
            
            game.camera.x = Math.max(0, Math.min(game.config.ARENA_WIDTH - canvas.width, game.camera.x));
            game.camera.y = Math.max(0, Math.min(game.config.ARENA_HEIGHT - canvas.height, game.camera.y));
        }
        
        function drawGrid() {
            if (!game.config) return;
            
            ctx.strokeStyle = 'rgba(0, 245, 255, 0.1)';
            ctx.lineWidth = 1;
            
            const gridSize = 50;
            const startX = Math.floor(game.camera.x / gridSize) * gridSize;
            const startY = Math.floor(game.camera.y / gridSize) * gridSize;
            
            for (let x = startX; x < game.camera.x + canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x - game.camera.x, 0);
                ctx.lineTo(x - game.camera.x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = startY; y < game.camera.y + canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y - game.camera.y);
                ctx.lineTo(canvas.width, y - game.camera.y);
                ctx.stroke();
            }
        }
        
        function drawBorders() {
            if (!game.config) return;
            
            ctx.strokeStyle = '#ff006e';
            ctx.lineWidth = 8;
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#ff006e';
            ctx.strokeRect(
                -game.camera.x,
                -game.camera.y,
                game.config.ARENA_WIDTH,
                game.config.ARENA_HEIGHT
            );
            ctx.shadowBlur = 0;
        }
        
        function drawPlayer(player, color = '#00f5ff', isLocalPlayer = false) {
            const screenX = player.x - game.camera.x;
            const screenY = player.y - game.camera.y;
            
            if (player.invulnerable && Math.floor(Date.now() / 100) % 2 === 0) {
                return;
            }
            
            // Bounty glow
            if (player.bountyMultiplier > 1.0) {
                let glowColor, glowSize;
                if (player.bountyMultiplier >= 3.0) {
                    glowColor = '#ff006e';
                    glowSize = 40;
                } else if (player.bountyMultiplier >= 2.0) {
                    glowColor = '#ffaa00';
                    glowSize = 35;
                } else {
                    glowColor = '#00f550';
                    glowSize = 30;
                }
                
                ctx.beginPath();
                ctx.arc(screenX, screenY, glowSize, 0, Math.PI * 2);
                ctx.strokeStyle = glowColor;
                ctx.lineWidth = 3;
                ctx.shadowBlur = 20;
                ctx.shadowColor = glowColor;
                ctx.globalAlpha = 0.6 + Math.sin(Date.now() / 200) * 0.2;
                ctx.stroke();
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1.0;
            }
            
            // Charging effect
            if (isLocalPlayer && game.charging.active) {
                const chargeLevel = getChargeLevel();
                let chargeColor = '#00f5ff';
                if (chargeLevel === 2) chargeColor = '#ff006e';
                else if (chargeLevel === 1) chargeColor = '#ffaa00';
                
                const pulseSize = 28 + Math.sin(Date.now() / 80) * 4;
                ctx.beginPath();
                ctx.arc(screenX, screenY, pulseSize, 0, Math.PI * 2);
                ctx.strokeStyle = chargeColor;
                ctx.lineWidth = 4;
                ctx.shadowBlur = 20;
                ctx.shadowColor = chargeColor;
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
            
            // Draw barrel with glow
            ctx.save();
            ctx.translate(screenX, screenY);
            ctx.rotate(player.angle);
            
            const barrelLength = 35;
            const barrelWidth = 12;
            
            ctx.shadowBlur = 15;
            ctx.shadowColor = color;
            ctx.fillStyle = color;
            ctx.fillRect(0, -barrelWidth/2, barrelLength, barrelWidth);
            ctx.shadowBlur = 0;
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(barrelLength - 8, -barrelWidth/2 + 2, 6, barrelWidth - 4);
            
            ctx.restore();
            
            // Draw body
            ctx.beginPath();
            ctx.arc(screenX, screenY, game.config.PLAYER.RADIUS, 0, Math.PI * 2);
            
            const gradient = ctx.createRadialGradient(
                screenX - 5, screenY - 5, 0,
                screenX, screenY, game.config.PLAYER.RADIUS
            );
            gradient.addColorStop(0, color);
            gradient.addColorStop(1, color.replace('ff', '88'));
            ctx.fillStyle = gradient;
            ctx.shadowBlur = 20;
            ctx.shadowColor = color;
            ctx.fill();
            ctx.shadowBlur = 0;
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Energy indicator ring
            if (player.energy < 100) {
                const energyAngle = (player.energy / 100) * Math.PI * 2 - Math.PI / 2;
                ctx.beginPath();
                ctx.arc(screenX, screenY, game.config.PLAYER.RADIUS + 4, -Math.PI / 2, energyAngle);
                let energyColor;
                if (player.energy >= 70) energyColor = '#00f550';
                else if (player.energy >= 30) energyColor = '#ffaa00';
                else energyColor = '#ff006e';
                ctx.strokeStyle = energyColor;
                ctx.lineWidth = 3;
                ctx.shadowBlur = 10;
                ctx.shadowColor = energyColor;
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
        }
        
        function drawOtherPlayers() {
            Object.values(game.otherPlayers).forEach(player => {
                const displayPlayer = {
                    ...player,
                    x: player.renderX,
                    y: player.renderY
                };
                drawPlayer(displayPlayer, '#ffaa00', false);
            });
        }
        
        function drawBullets() {
            Object.values(game.bullets).forEach(bullet => {
                const screenX = bullet.renderX - game.camera.x;
                const screenY = bullet.renderY - game.camera.y;
                
                let color = '#00f5ff';
                if (bullet.chargeLevel === 2) color = '#ff006e';
                else if (bullet.chargeLevel === 1) color = '#ffaa00';
                
                ctx.beginPath();
                ctx.arc(screenX, screenY, bullet.radius, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.shadowBlur = 15;
                ctx.shadowColor = color;
                ctx.fill();
                ctx.shadowBlur = 0;
                
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }
        
        function drawMoney() {
            Object.values(game.money).forEach(money => {
                const screenX = money.x - game.camera.x;
                const screenY = money.y - game.camera.y;
                
                ctx.beginPath();
                ctx.arc(screenX, screenY, money.radius, 0, Math.PI * 2);
                
                const gradient = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, money.radius);
                gradient.addColorStop(0, '#FFD700');
                gradient.addColorStop(1, '#FFA500');
                ctx.fillStyle = gradient;
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#FFD700';
                ctx.fill();
                ctx.shadowBlur = 0;
                
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('$', screenX, screenY + 6);
            });
        }
        
        function drawParticles() {
            particles.forEach(particle => {
                particle.draw(game.camera);
            });
        }
        
        function drawUI() {
            if (!game.player) return;
            
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            
            // Energy bar
            const barBg = ctx.createLinearGradient(20, 20, 20, 130);
            barBg.addColorStop(0, 'rgba(0, 0, 0, 0.6)');
            barBg.addColorStop(1, 'rgba(0, 0, 0, 0.4)');
            
            ctx.fillStyle = barBg;
            ctx.fillRect(15, 15, 120, 120);
            ctx.strokeStyle = 'rgba(0, 245, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.strokeRect(15, 15, 120, 120);
            
            ctx.fillStyle = '#00f5ff';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'left';
            ctx.shadowBlur = 5;
            ctx.shadowColor = '#00f5ff';
            ctx.fillText('ENERGY', 25, 35);
            ctx.shadowBlur = 0;
            
            const barX = 25;
            const barY = 45;
            const segmentWidth = 16;
            const segmentHeight = 8;
            const segmentSpacing = 2;
            const maxSegments = 20;
            const filledSegments = Math.floor(game.player.energy / 5);
            
            for (let i = 0; i < maxSegments; i++) {
                const x = barX + (i % 4) * (segmentWidth + segmentSpacing);
                const y = barY + Math.floor(i / 4) * (segmentHeight + segmentSpacing);
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.fillRect(x, y, segmentWidth, segmentHeight);
                
                if (i < filledSegments) {
                    let segColor;
                    if (game.player.energy >= 70) segColor = '#00f550';
                    else if (game.player.energy >= 30) segColor = '#ffaa00';
                    else segColor = '#ff006e';
                    
                    ctx.fillStyle = segColor;
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = segColor;
                    ctx.fillRect(x + 1, y + 1, segmentWidth - 2, segmentHeight - 2);
                    ctx.shadowBlur = 0;
                }
            }
            
            // Bounty info
            if (game.player.bountyMultiplier > 1.0) {
                const bountyBg = ctx.createLinearGradient(canvas.width - 180, 15, canvas.width - 180, 85);
                bountyBg.addColorStop(0, 'rgba(255, 0, 110, 0.3)');
                bountyBg.addColorStop(1, 'rgba(255, 0, 110, 0.1)');
                
                ctx.fillStyle = bountyBg;
                ctx.fillRect(canvas.width - 185, 15, 170, 70);
                ctx.strokeStyle = 'rgba(255, 0, 110, 0.5)';
                ctx.lineWidth = 2;
                ctx.strokeRect(canvas.width - 185, 15, 170, 70);
                
                ctx.fillStyle = '#ff006e';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'left';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ff006e';
                ctx.fillText(`BOUNTY: ${game.player.bountyMultiplier.toFixed(1)}x`, canvas.width - 175, 38);
                
                ctx.font = 'bold 14px Arial';
                ctx.fillText(`Kill Streak: ${game.player.killStreak}`, canvas.width - 175, 65);
                ctx.shadowBlur = 0;
            }
            
            // Debug info
            const debugBg = ctx.createLinearGradient(10, canvas.height - 60, 10, canvas.height - 10);
            debugBg.addColorStop(0, 'rgba(0, 0, 0, 0.7)');
            debugBg.addColorStop(1, 'rgba(0, 0, 0, 0.5)');
            
            ctx.fillStyle = debugBg;
            ctx.fillRect(10, canvas.height - 75, 160, 65);
            ctx.strokeStyle = 'rgba(0, 245, 255, 0.2)';
            ctx.lineWidth = 2;
            ctx.strokeRect(10, canvas.height - 75, 160, 65);
            
            ctx.font = 'bold 13px monospace';
            ctx.textAlign = 'left';
            
            ctx.fillStyle = '#00f550';
            ctx.shadowBlur = 5;
            ctx.shadowColor = '#00f550';
            ctx.fillText(`FPS: ${Math.round(game.fps)}`, 20, canvas.height - 53);
            
            const pingColor = game.ping < 50 ? '#00f550' : game.ping < 100 ? '#ffaa00' : '#ff006e';
            ctx.fillStyle = pingColor;
            ctx.shadowColor = pingColor;
            ctx.fillText(`PING: ${game.ping}ms`, 20, canvas.height - 36);
            
            ctx.fillStyle = '#00f5ff';
            ctx.shadowColor = '#00f5ff';
            ctx.fillText(`TICK: ${game.serverTick}`, 20, canvas.height - 19);
            
            ctx.shadowBlur = 0;
            
            ctx.restore();
        }
        
        function render() {
            // Dark background with gradient
            const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            bgGradient.addColorStop(0, '#0a0e27');
            bgGradient.addColorStop(1, '#16213e');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            drawGrid();
            drawBorders();
            drawMoney();
            drawParticles();
            drawBullets();
            drawOtherPlayers();
            
            if (game.player) {
                drawPlayer(game.player, '#00f5ff', true);
            }
            
            drawUI();
        }
        
        // ==================== MAIN LOOP (FIXED TIMESTEP) ====================
        function gameLoop(currentTime) {
            // FPS counter
            frameCount++;
            if (currentTime - lastFpsUpdate >= 1000) {
                game.fps = frameCount;
                frameCount = 0;
                lastFpsUpdate = currentTime;
            }
            
            // Calculate delta time normalized to match server (60Hz baseline = 1.0)
            const rawDelta = (currentTime - lastFrameTime);
            const deltaTime = rawDelta / (1000 / 60);
            lastFrameTime = currentTime;
            
            // Run physics at native framerate but normalized to server
            processInput(deltaTime);
            updateParticles(deltaTime);
            updatePredictedBullets(deltaTime);
            
            // Interpolate other entities
            interpolateEntities(0.2);
            updateCamera();
            
            // Render
            render();
            
            requestAnimationFrame(gameLoop);
        }
        
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>