<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STRAFE - Multiplayer Tank Arena</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #cdcdcd;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 2px solid #555;
            background: #f0f0f0;
        }
        #connectionStatus {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 1000;
        }
        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 999;
        }
        #loadingScreen h2 {
            margin: 10px;
            font-size: 48px;
        }
        #loadingScreen.hidden {
            display: none;
        }
        .status-good { background: rgba(76, 175, 80, 0.8) !important; }
        .status-warning { background: rgba(255, 152, 0, 0.8) !important; }
        .status-bad { background: rgba(231, 76, 60, 0.8) !important; }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <h2>ðŸŽ® STRAFE</h2>
        <p>Connecting to server...</p>
        <p style="font-size: 12px; color: #888;">Server may be waking up (30-60s)</p>
    </div>
    <div id="connectionStatus">Connecting...</div>
    <canvas id="gameCanvas"></canvas>
    
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = 1200;
        canvas.height = 800;
        
        // ==================== GAME STATE ====================
        const game = {
            myId: null,
            config: null,
            connected: false,
            
            // Local player (with prediction)
            player: null,
            
            // Other players (interpolated)
            otherPlayers: {},
            
            // Bullets (with interpolation)
            bullets: {},
            
            // Money pickups
            money: {},
            
            // Input handling
            inputSequence: 0,
            pendingInputs: [],
            
            // Rendering
            camera: { x: 0, y: 0 },
            
            // Diagnostics
            ping: 0,
            fps: 60,
            serverTick: 0,
            
            // Mouse
            mouse: { x: 0, y: 0 },
            
            // Charging
            charging: {
                active: false,
                startTime: 0
            }
        };
        
        // Frame timing
        let lastFrameTime = performance.now();
        let frameCount = 0;
        let lastFpsUpdate = performance.now();
        
        // ==================== SOCKET CONNECTION ====================
        const socket = io({
            reconnection: true,
            reconnectionDelay: 1000,
            reconnectionDelayMax: 5000,
            reconnectionAttempts: 5
        });
        
        socket.on('connect', () => {
            console.log('Connected to server');
            game.connected = true;
            updateConnectionStatus('Connected', 'status-good');
        });
        
        socket.on('disconnect', () => {
            console.log('Disconnected from server');
            game.connected = false;
            updateConnectionStatus('Disconnected - Reconnecting...', 'status-bad');
            document.getElementById('loadingScreen').classList.remove('hidden');
        });
        
        socket.on('init', (data) => {
            console.log('Received init data:', data);
            game.myId = data.playerId;
            game.config = data.config;
            
            // Initialize local player
            const myData = data.gameState.players[game.myId];
            game.player = {
                ...myData,
                velocityX: 0,
                velocityY: 0
            };
            
            // Initialize other players
            Object.values(data.gameState.players).forEach(p => {
                if (p.id !== game.myId) {
                    game.otherPlayers[p.id] = {
                        ...p,
                        renderX: p.x,
                        renderY: p.y
                    };
                }
            });
            
            // Initialize bullets with interpolation data
            data.gameState.bullets.forEach(b => {
                game.bullets[b.id] = {
                    ...b,
                    renderX: b.x,
                    renderY: b.y,
                    prevX: b.x,
                    prevY: b.y
                };
            });
            
            // Initialize money
            data.gameState.money.forEach(m => {
                game.money[m.id] = m;
            });
            
            document.getElementById('loadingScreen').classList.add('hidden');
            updateConnectionStatus(`Connected | Players: ${Object.keys(data.gameState.players).length}`, 'status-good');
        });
        
        socket.on('gameState', (snapshot) => {
            game.serverTick = snapshot.tick;
            
            // Update other players (with interpolation)
            snapshot.players.forEach(serverPlayer => {
                if (serverPlayer.id === game.myId) {
                    // Server reconciliation for local player
                    reconcileServerState(serverPlayer);
                } else {
                    // Update other players
                    if (!game.otherPlayers[serverPlayer.id]) {
                        game.otherPlayers[serverPlayer.id] = {
                            ...serverPlayer,
                            renderX: serverPlayer.x,
                            renderY: serverPlayer.y
                        };
                    } else {
                        const player = game.otherPlayers[serverPlayer.id];
                        
                        // Store previous position for interpolation
                        player.prevX = player.x;
                        player.prevY = player.y;
                        player.prevAngle = player.angle;
                        
                        // Update to new server position
                        Object.assign(player, serverPlayer);
                        
                        // Initialize render position if needed
                        if (player.renderX === undefined) {
                            player.renderX = player.x;
                            player.renderY = player.y;
                        }
                    }
                }
            });
            
            // Remove disconnected players
            Object.keys(game.otherPlayers).forEach(id => {
                if (!snapshot.players.find(p => p.id === id)) {
                    delete game.otherPlayers[id];
                }
            });
            
            // Update bullets with interpolation
            const newBullets = {};
            snapshot.bullets.forEach(b => {
                if (game.bullets[b.id]) {
                    // Existing bullet - store prev position
                    const bullet = game.bullets[b.id];
                    bullet.prevX = bullet.x;
                    bullet.prevY = bullet.y;
                    Object.assign(bullet, b);
                } else {
                    // New bullet - initialize interpolation
                    newBullets[b.id] = {
                        ...b,
                        renderX: b.x,
                        renderY: b.y,
                        prevX: b.x,
                        prevY: b.y
                    };
                }
            });
            
            // Remove old bullets
            Object.keys(game.bullets).forEach(id => {
                if (snapshot.bullets.find(b => b.id === id)) {
                    newBullets[id] = game.bullets[id];
                }
            });
            
            game.bullets = newBullets;
            
            // Update money
            game.money = {};
            snapshot.money.forEach(m => {
                game.money[m.id] = m;
            });
            
            updateConnectionStatus(
                `Connected | Players: ${snapshot.players.length} | Ping: ${game.ping}ms`, 
                game.ping < 100 ? 'status-good' : game.ping < 200 ? 'status-warning' : 'status-bad'
            );
        });
        
        socket.on('bulletSpawned', (bullet) => {
            game.bullets[bullet.id] = {
                ...bullet,
                renderX: bullet.x,
                renderY: bullet.y,
                prevX: bullet.x,
                prevY: bullet.y
            };
        });
        
        socket.on('bulletRemoved', (bulletId) => {
            delete game.bullets[bulletId];
        });
        
        socket.on('playerHit', (data) => {
            // Update energy display
            if (data.targetId === game.myId) {
                game.player.energy = data.energy;
            } else if (game.otherPlayers[data.targetId]) {
                game.otherPlayers[data.targetId].energy = data.energy;
            }
        });
        
        socket.on('playerDied', (data) => {
            if (data.playerId === game.myId) {
                // We died - update local state
                game.player.x = data.respawn.x;
                game.player.y = data.respawn.y;
                game.player.velocityX = 0;
                game.player.velocityY = 0;
                game.player.energy = data.respawn.energy;
                game.player.dollarValue = data.respawn.dollarValue;
                game.player.invulnerable = true;
                game.player.invulnerableUntil = data.respawn.invulnerableUntil;
                game.player.killStreak = 0;
                game.player.bountyMultiplier = 1.0;
                
                // Clear pending inputs
                game.pendingInputs = [];
            }
            
            // Add money drop
            if (data.moneyDrop) {
                game.money[data.moneyDrop.id] = data.moneyDrop;
            }
        });
        
        socket.on('moneyPickedUp', (data) => {
            delete game.money[data.moneyId];
            
            if (data.playerId === game.myId) {
                game.player.dollarValue = data.newDollarValue;
            }
        });
        
        socket.on('playerJoined', (player) => {
            if (player.id !== game.myId) {
                game.otherPlayers[player.id] = {
                    ...player,
                    renderX: player.x,
                    renderY: player.y
                };
            }
        });
        
        socket.on('playerLeft', (playerId) => {
            delete game.otherPlayers[playerId];
        });
        
        // Ping measurement
        socket.on('pong', (timestamp) => {
            game.ping = Date.now() - timestamp;
        });
        
        setInterval(() => {
            if (game.connected) {
                socket.emit('ping', Date.now());
            }
        }, 2000);
        
        function updateConnectionStatus(text, className) {
            const status = document.getElementById('connectionStatus');
            status.textContent = text;
            status.className = className;
        }
        
        // ==================== SERVER RECONCILIATION ====================
        function reconcileServerState(serverPlayer) {
            if (!game.player) return;
            
            // Calculate position error
            const errorX = serverPlayer.x - game.player.x;
            const errorY = serverPlayer.y - game.player.y;
            const errorDistance = Math.hypot(errorX, errorY);
            
            // If error is small, smoothly correct it
            if (errorDistance < 5) {
                game.player.x += errorX * 0.1;
                game.player.y += errorY * 0.1;
            } else if (errorDistance < 20) {
                // Medium error - faster correction
                game.player.x += errorX * 0.3;
                game.player.y += errorY * 0.3;
            } else {
                // Large error - snap to server position
                console.warn('Large position error detected, snapping to server');
                game.player.x = serverPlayer.x;
                game.player.y = serverPlayer.y;
                game.player.velocityX = serverPlayer.velocityX;
                game.player.velocityY = serverPlayer.velocityY;
            }
            
            // Always trust server for these values
            game.player.energy = serverPlayer.energy;
            game.player.dollarValue = serverPlayer.dollarValue;
            game.player.invulnerable = serverPlayer.invulnerable;
            game.player.killStreak = serverPlayer.killStreak;
            game.player.bountyMultiplier = serverPlayer.bountyMultiplier;
            
            // Remove acknowledged inputs
            if (game.pendingInputs.length > 10) {
                game.pendingInputs = game.pendingInputs.slice(-5);
            }
        }
        
        // ==================== INPUT HANDLING ====================
        const keys = {};
        
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            game.mouse.x = e.clientX - rect.left;
            game.mouse.y = e.clientY - rect.top;
        });
        
        canvas.addEventListener('mousedown', () => {
            if (!game.player || !game.connected) return;
            
            // Start charging
            game.charging.active = true;
            game.charging.startTime = Date.now();
            
            // Shoot immediate bullet
            shoot(0);
        });
        
        canvas.addEventListener('mouseup', () => {
            if (!game.player || !game.connected || !game.charging.active) return;
            
            const chargeTime = Date.now() - game.charging.startTime;
            let chargeLevel = 0;
            
            if (chargeTime >= 1000) chargeLevel = 2;
            else if (chargeTime >= 500) chargeLevel = 1;
            
            if (chargeLevel > 0) {
                shoot(chargeLevel);
            }
            
            game.charging.active = false;
        });
        
        function shoot(chargeLevel) {
            if (!game.player || !game.config) return;
            
            const bulletTypes = game.config.BULLET.TYPES;
            let bulletType;
            
            switch(chargeLevel) {
                case 1: bulletType = bulletTypes.CHARGED1; break;
                case 2: bulletType = bulletTypes.CHARGED2; break;
                default: bulletType = bulletTypes.NORMAL;
            }
            
            if (game.player.energy < bulletType.energyCost) return;
            
            // Optimistic local prediction
            game.player.energy -= bulletType.energyCost;
            
            // Send to server
            socket.emit('shoot', {
                chargeLevel: chargeLevel,
                timestamp: Date.now()
            });
        }
        
        function getChargeLevel() {
            if (!game.charging.active) return 0;
            const chargeTime = Date.now() - game.charging.startTime;
            if (chargeTime >= 1000) return 2;
            if (chargeTime >= 500) return 1;
            return 0;
        }
        
        // ==================== CLIENT PREDICTION ====================
        function processInput(deltaTime) {
            if (!game.player || !game.connected) return;
            
            const input = {
                sequence: game.inputSequence++,
                timestamp: Date.now(),
                up: keys['w'] || keys['arrowup'],
                down: keys['s'] || keys['arrowdown'],
                left: keys['a'] || keys['arrowleft'],
                right: keys['d'] || keys['arrowright'],
                boost: keys[' '],
                angle: Math.atan2(
                    game.mouse.y - (game.player.y - game.camera.y),
                    game.mouse.x - (game.player.x - game.camera.x)
                )
            };
            
            // Send to server
            socket.emit('input', input);
            
            // Store for reconciliation
            game.pendingInputs.push(input);
            
            // Apply locally for prediction
            applyInput(game.player, input, deltaTime);
        }
        
        function applyInput(player, input, deltaTime) {
            if (!game.config) return;
            
            // Movement
            let inputX = 0;
            let inputY = 0;
            
            if (input.up) inputY -= 1;
            if (input.down) inputY += 1;
            if (input.left) inputX -= 1;
            if (input.right) inputX += 1;
            
            // Normalize diagonal
            if (inputX !== 0 && inputY !== 0) {
                const length = Math.hypot(inputX, inputY);
                inputX /= length;
                inputY /= length;
            }
            
            // Apply acceleration
            const accel = game.config.PLAYER.ACCELERATION * deltaTime;
            player.velocityX += inputX * accel;
            player.velocityY += inputY * accel;
            
            // Apply momentum
            const momentum = Math.pow(game.config.PLAYER.MOMENTUM, deltaTime);
            player.velocityX *= momentum;
            player.velocityY *= momentum;
            
            // Handle boost
            const isBoosting = input.boost && player.energy > 0;
            if (isBoosting) {
                player.energy = Math.max(0, player.energy - game.config.PLAYER.ENERGY.BOOST_DRAIN * deltaTime);
            } else {
                player.energy = Math.min(
                    game.config.PLAYER.ENERGY.MAX,
                    player.energy + game.config.PLAYER.ENERGY.REGEN * deltaTime
                );
            }
            
            // Cap velocity
            const maxVel = isBoosting ? game.config.PLAYER.MAX_BOOST_VELOCITY : game.config.PLAYER.MAX_VELOCITY;
            const speed = Math.hypot(player.velocityX, player.velocityY);
            if (speed > maxVel) {
                player.velocityX = (player.velocityX / speed) * maxVel;
                player.velocityY = (player.velocityY / speed) * maxVel;
            }
            
            // Update position
            player.x += player.velocityX * deltaTime;
            player.y += player.velocityY * deltaTime;
            
            // Update angle
            player.angle = input.angle;
            
            // Update invulnerability
            if (player.invulnerable && Date.now() > player.invulnerableUntil) {
                player.invulnerable = false;
            }
        }
        
        // ==================== INTERPOLATION ====================
        function interpolateEntities(alpha) {
            // Interpolate other players
            Object.values(game.otherPlayers).forEach(player => {
                if (player.prevX !== undefined) {
                    player.renderX += (player.x - player.renderX) * alpha;
                    player.renderY += (player.y - player.renderY) * alpha;
                } else {
                    player.renderX = player.x;
                    player.renderY = player.y;
                }
            });
            
            // Interpolate bullets (SMOOTH!)
            Object.values(game.bullets).forEach(bullet => {
                if (bullet.prevX !== undefined) {
                    // Interpolate toward current position
                    bullet.renderX += (bullet.x - bullet.renderX) * alpha;
                    bullet.renderY += (bullet.y - bullet.renderY) * alpha;
                } else {
                    bullet.renderX = bullet.x;
                    bullet.renderY = bullet.y;
                }
            });
        }
        
        // ==================== RENDERING ====================
        function updateCamera() {
            if (!game.player || !game.config) return;
            
            game.camera.x = game.player.x - canvas.width / 2;
            game.camera.y = game.player.y - canvas.height / 2;
            
            game.camera.x = Math.max(0, Math.min(game.config.ARENA_WIDTH - canvas.width, game.camera.x));
            game.camera.y = Math.max(0, Math.min(game.config.ARENA_HEIGHT - canvas.height, game.camera.y));
        }
        
        function drawGrid() {
            if (!game.config) return;
            
            ctx.strokeStyle = '#d0d0d0';
            ctx.lineWidth = 1;
            
            const gridSize = 50;
            const startX = Math.floor(game.camera.x / gridSize) * gridSize;
            const startY = Math.floor(game.camera.y / gridSize) * gridSize;
            
            for (let x = startX; x < game.camera.x + canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x - game.camera.x, 0);
                ctx.lineTo(x - game.camera.x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = startY; y < game.camera.y + canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y - game.camera.y);
                ctx.lineTo(canvas.width, y - game.camera.y);
                ctx.stroke();
            }
        }
        
        function drawBorders() {
            if (!game.config) return;
            
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 10;
            ctx.strokeRect(
                -game.camera.x,
                -game.camera.y,
                game.config.ARENA_WIDTH,
                game.config.ARENA_HEIGHT
            );
        }
        
        function drawPlayer(player, color = '#00b2e1', isLocalPlayer = false) {
            const screenX = player.x - game.camera.x;
            const screenY = player.y - game.camera.y;
            
            // Skip if invulnerable and blinking
            if (player.invulnerable && Math.floor(Date.now() / 100) % 2 === 0) {
                return;
            }
            
            // Bounty glow
            if (player.bountyMultiplier > 1.0) {
                let glowColor, glowSize;
                if (player.bountyMultiplier >= 3.0) {
                    glowColor = '#FF4500';
                    glowSize = 35;
                } else if (player.bountyMultiplier >= 2.0) {
                    glowColor = '#FFD700';
                    glowSize = 32;
                } else {
                    glowColor = '#4CAF50';
                    glowSize = 28;
                }
                
                ctx.beginPath();
                ctx.arc(screenX, screenY, glowSize, 0, Math.PI * 2);
                ctx.strokeStyle = glowColor;
                ctx.lineWidth = 3;
                ctx.globalAlpha = 0.6 + Math.sin(Date.now() / 200) * 0.2;
                ctx.stroke();
                ctx.globalAlpha = 1.0;
            }
            
            // Charging effect
            if (isLocalPlayer && game.charging.active) {
                const chargeLevel = getChargeLevel();
                let chargeColor = '#00b2e1';
                if (chargeLevel === 2) chargeColor = '#FF4500';
                else if (chargeLevel === 1) chargeColor = '#FFD700';
                
                const pulseSize = 25 + Math.sin(Date.now() / 100) * 3;
                ctx.beginPath();
                ctx.arc(screenX, screenY, pulseSize, 0, Math.PI * 2);
                ctx.strokeStyle = chargeColor;
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            
            // Draw barrel
            ctx.save();
            ctx.translate(screenX, screenY);
            ctx.rotate(player.angle);
            
            ctx.fillStyle = '#888';
            ctx.fillRect(10, -7.5, 35, 15);
            
            ctx.restore();
            
            // Draw body
            ctx.beginPath();
            ctx.arc(screenX, screenY, 20, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Draw dollar value
            ctx.fillStyle = '#FFD700';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.strokeText(`$${player.dollarValue.toFixed(2)}`, screenX, screenY - 30);
            ctx.fillText(`$${player.dollarValue.toFixed(2)}`, screenX, screenY - 30);
        }
        
        function drawOtherPlayers() {
            Object.values(game.otherPlayers).forEach(player => {
                // Use interpolated render position
                const renderPlayer = {
                    ...player,
                    x: player.renderX,
                    y: player.renderY
                };
                drawPlayer(renderPlayer, '#e74c3c', false);
            });
        }
        
        function drawBullets() {
            Object.values(game.bullets).forEach(bullet => {
                // Use interpolated position (SMOOTH!)
                const screenX = bullet.renderX - game.camera.x;
                const screenY = bullet.renderY - game.camera.y;
                
                let color = '#00b2e1';
                if (bullet.chargeLevel === 2) color = '#FF4500';
                else if (bullet.chargeLevel === 1) color = '#FFD700';
                
                ctx.beginPath();
                ctx.arc(screenX, screenY, bullet.radius, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
                ctx.strokeStyle = '#555';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }
        
        function drawMoney() {
            Object.values(game.money).forEach(money => {
                const screenX = money.x - game.camera.x;
                const screenY = money.y - game.camera.y;
                
                ctx.beginPath();
                ctx.arc(screenX, screenY, money.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#FFD700';
                ctx.fill();
                ctx.strokeStyle = '#FFA500';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                ctx.fillStyle = '#000';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('$', screenX, screenY + 5);
                
                ctx.fillStyle = '#333';
                ctx.font = 'bold 10px Arial';
                ctx.fillText(money.amount.toFixed(2), screenX, screenY + money.radius + 12);
            });
        }
        
        function drawUI() {
            if (!game.player) return;
            
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            
            // Energy bar
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('ENERGY', 20, 20);
            
            const barX = 20;
            const barY = 35;
            const segmentWidth = 16;
            const segmentHeight = 8;
            const segmentSpacing = 2;
            const maxSegments = 20;
            const filledSegments = Math.floor(game.player.energy / 5);
            
            for (let i = 0; i < maxSegments; i++) {
                const x = barX + (i % 4) * (segmentWidth + segmentSpacing);
                const y = barY + Math.floor(i / 4) * (segmentHeight + segmentSpacing);
                
                ctx.fillStyle = '#555';
                ctx.fillRect(x, y, segmentWidth, segmentHeight);
                
                if (i < filledSegments) {
                    if (game.player.energy >= 70) ctx.fillStyle = '#4CAF50';
                    else if (game.player.energy >= 30) ctx.fillStyle = '#FFD700';
                    else ctx.fillStyle = '#e74c3c';
                    
                    ctx.fillRect(x + 1, y + 1, segmentWidth - 2, segmentHeight - 2);
                }
            }
            
            // Bounty info
            if (game.player.bountyMultiplier > 1.0) {
                ctx.fillStyle = '#333';
                ctx.font = 'bold 18px Arial';
                ctx.fillText(`BOUNTY: ${game.player.bountyMultiplier.toFixed(1)}x`, 120, 20);
                
                ctx.font = 'bold 14px Arial';
                ctx.fillText(`Streak: ${game.player.killStreak}`, 120, 40);
            }
            
            // Debug info
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(10, canvas.height - 70, 150, 60);
            
            ctx.fillStyle = '#0f0';
            ctx.font = 'bold 12px monospace';
            ctx.fillText(`FPS: ${Math.round(game.fps)}`, 20, canvas.height - 50);
            
            const pingColor = game.ping < 50 ? '#0f0' : game.ping < 100 ? '#ff0' : '#f00';
            ctx.fillStyle = pingColor;
            ctx.fillText(`PING: ${game.ping}ms`, 20, canvas.height - 35);
            
            ctx.fillStyle = '#0ff';
            ctx.fillText(`TICK: ${game.serverTick}`, 20, canvas.height - 20);
            
            ctx.restore();
        }
        
        // ==================== MAIN LOOP ====================
        function gameLoop(currentTime) {
            // Calculate FPS
            frameCount++;
            if (currentTime - lastFpsUpdate >= 1000) {
                game.fps = frameCount;
                frameCount = 0;
                lastFpsUpdate = currentTime;
            }
            
            // Calculate delta time
            const deltaTime = Math.min((currentTime - lastFrameTime) / (1000 / 60), 3);
            lastFrameTime = currentTime;
            
            // Process input and prediction
            processInput(deltaTime);
            
            // Interpolate entities (0.3 = 30% lerp per frame for smoothness)
            interpolateEntities(0.3);
            
            // Update camera
            updateCamera();
            
            // Clear canvas
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw everything
            drawGrid();
            drawBorders();
            drawMoney();
            drawBullets();
            drawOtherPlayers();
            
            if (game.player) {
                drawPlayer(game.player, '#00b2e1', true);
            }
            
            drawUI();
            
            requestAnimationFrame(gameLoop);
        }
        
        // Start game loop
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>