<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STRAFE - Arena</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        #gameContainer {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            position: relative;
        }
        
        canvas {
            border: 3px solid rgba(0, 245, 255, 0.5);
            box-shadow: 0 0 60px rgba(0, 245, 255, 0.3);
            border-radius: 10px;
        }
        
        #connectionStatus {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            color: #00f5ff;
            padding: 12px 20px;
            border-radius: 10px;
            font-size: 14px;
            font-weight: bold;
            z-index: 1000;
            border: 2px solid rgba(0, 245, 255, 0.3);
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.2);
        }
        
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 9999;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        #loadingScreen h2 {
            font-size: 72px;
            font-weight: 900;
            letter-spacing: -2px;
            background: linear-gradient(45deg, #00f5ff, #ff00ff, #ffaa00);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradient 3s ease infinite;
            margin-bottom: 20px;
        }
        
        @keyframes gradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        #loadingScreen p {
            font-size: 18px;
            opacity: 0.9;
        }
        
        #loadingScreen.hidden {
            display: none;
        }
        
        .status-good { 
            background: rgba(0, 245, 80, 0.2) !important;
            border-color: rgba(0, 245, 80, 0.5) !important;
            color: #00f550 !important;
        }
        .status-warning { 
            background: rgba(255, 170, 0, 0.2) !important;
            border-color: rgba(255, 170, 0, 0.5) !important;
            color: #ffaa00 !important;
        }
        .status-bad { 
            background: rgba(255, 0, 110, 0.2) !important;
            border-color: rgba(255, 0, 110, 0.5) !important;
            color: #ff006e !important;
        }
        
        #backButton {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 12px 24px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 0, 255, 0.3);
            border-radius: 10px;
            color: #ff00ff;
            text-decoration: none;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
            z-index: 1000;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.2);
        }
        
        #backButton:hover {
            background: rgba(255, 0, 255, 0.2);
            border-color: rgba(255, 0, 255, 0.6);
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.4);
            transform: translateY(-2px);
        }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <h2>STRAFE</h2>
        <p>Connecting to server...</p>
        <p style="font-size: 14px; color: rgba(255,255,255,0.6); margin-top: 10px;">Server may be waking up (30-60s)</p>
    </div>
    
    <div id="gameContainer">
        <a href="/" id="backButton">‚Üê BACK TO MENU</a>
        <div id="connectionStatus">Connecting...</div>
        <canvas id="gameCanvas"></canvas>
    </div>
    
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = 1200;
        canvas.height = 800;
        
        // Particle system for visual effects
        const particles = [];
        
        // ==================== GAME STATE ====================
        const game = {
            myId: null,
            config: null,
            connected: false,
            player: null,
            otherPlayers: {},
            bullets: {},
            money: {},
            inputSequence: 0,
            pendingInputs: [],
            camera: { x: 0, y: 0 },
            ping: 0,
            fps: 60,
            serverTick: 0,
            mouse: { x: 0, y: 0 },
            charging: { active: false, startTime: 0 }
        };
        
        let lastFrameTime = performance.now();
        let frameCount = 0;
        let lastFpsUpdate = performance.now();
        
        // ==================== PARTICLE EFFECTS ====================
        class Particle {
            constructor(x, y, color, size = 3, vx = 0, vy = 0, lifetime = 1000) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = size;
                this.vx = vx;
                this.vy = vy;
                this.lifetime = lifetime;
                this.createdAt = Date.now();
                this.alpha = 1;
            }
            
            update(deltaTime) {
                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;
                
                const age = Date.now() - this.createdAt;
                this.alpha = 1 - (age / this.lifetime);
                
                return age < this.lifetime;
            }
            
            draw(camera) {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.arc(this.x - camera.x, this.y - camera.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        
        function createHitEffect(x, y, color) {
            for (let i = 0; i < 12; i++) {
                const angle = (Math.PI * 2 * i) / 12;
                const speed = 2 + Math.random() * 2;
                particles.push(new Particle(
                    x, y, color, 4,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    500
                ));
            }
        }
        
        function createBoostTrail(x, y, angle) {
            const offsetAngle = angle + Math.PI;
            const distance = 25;
            const px = x + Math.cos(offsetAngle) * distance;
            const py = y + Math.sin(offsetAngle) * distance;
            
            particles.push(new Particle(
                px, py,
                'rgba(0, 245, 255, 0.8)',
                3 + Math.random() * 2,
                Math.cos(offsetAngle) * 0.5,
                Math.sin(offsetAngle) * 0.5,
                300
            ));
        }
        
        // ==================== SOCKET CONNECTION ====================
        const socket = io({
            reconnection: true,
            reconnectionDelay: 1000,
            reconnectionDelayMax: 5000,
            reconnectionAttempts: 5
        });
        
        socket.on('connect', () => {
            console.log('Connected to server');
            game.connected = true;
            updateConnectionStatus('Connected', 'status-good');
        });
        
        socket.on('disconnect', () => {
            console.log('Disconnected from server');
            game.connected = false;
            updateConnectionStatus('Disconnected - Reconnecting...', 'status-bad');
            document.getElementById('loadingScreen').classList.remove('hidden');
        });
        
        socket.on('init', (data) => {
            console.log('Received init data:', data);
            game.myId = data.playerId;
            game.config = data.config;
            
            const myData = data.gameState.players[game.myId];
            game.player = { ...myData, velocityX: 0, velocityY: 0 };
            
            Object.values(data.gameState.players).forEach(p => {
                if (p.id !== game.myId) {
                    game.otherPlayers[p.id] = { ...p, renderX: p.x, renderY: p.y };
                }
            });
            
            data.gameState.bullets.forEach(b => {
                game.bullets[b.id] = { ...b, renderX: b.x, renderY: b.y, prevX: b.x, prevY: b.y };
            });
            
            data.gameState.money.forEach(m => {
                game.money[m.id] = m;
            });
            
            document.getElementById('loadingScreen').classList.add('hidden');
            updateConnectionStatus(`Connected | Players: ${Object.keys(data.gameState.players).length}`, 'status-good');
        });
        
        socket.on('gameState', (snapshot) => {
            game.serverTick = snapshot.tick;
            
            snapshot.players.forEach(serverPlayer => {
                if (serverPlayer.id === game.myId) {
                    reconcileServerState(serverPlayer);
                } else {
                    if (!game.otherPlayers[serverPlayer.id]) {
                        game.otherPlayers[serverPlayer.id] = {
                            ...serverPlayer,
                            renderX: serverPlayer.x,
                            renderY: serverPlayer.y
                        };
                    } else {
                        const player = game.otherPlayers[serverPlayer.id];
                        player.prevX = player.x;
                        player.prevY = player.y;
                        Object.assign(player, serverPlayer);
                        if (player.renderX === undefined) {
                            player.renderX = player.x;
                            player.renderY = player.y;
                        }
                    }
                }
            });
            
            Object.keys(game.otherPlayers).forEach(id => {
                if (!snapshot.players.find(p => p.id === id)) {
                    delete game.otherPlayers[id];
                }
            });
            
            const newBullets = {};
            snapshot.bullets.forEach(b => {
                if (game.bullets[b.id]) {
                    const bullet = game.bullets[b.id];
                    bullet.prevX = bullet.x;
                    bullet.prevY = bullet.y;
                    Object.assign(bullet, b);
                } else {
                    newBullets[b.id] = {
                        ...b,
                        renderX: b.x,
                        renderY: b.y,
                        prevX: b.x,
                        prevY: b.y
                    };
                }
            });
            
            Object.keys(game.bullets).forEach(id => {
                if (snapshot.bullets.find(b => b.id === id)) {
                    newBullets[id] = game.bullets[id];
                }
            });
            
            game.bullets = newBullets;
            
            game.money = {};
            snapshot.money.forEach(m => {
                game.money[m.id] = m;
            });
            
            updateConnectionStatus(
                `Players: ${snapshot.players.length} | ${game.ping}ms`, 
                game.ping < 100 ? 'status-good' : game.ping < 200 ? 'status-warning' : 'status-bad'
            );
        });
        
        socket.on('bulletSpawned', (bullet) => {
            game.bullets[bullet.id] = {
                ...bullet,
                renderX: bullet.x,
                renderY: bullet.y,
                prevX: bullet.x,
                prevY: bullet.y
            };
        });
        
        socket.on('bulletRemoved', (bulletId) => {
            delete game.bullets[bulletId];
        });
        
        socket.on('playerHit', (data) => {
            if (data.targetId === game.myId) {
                game.player.energy = data.energy;
                // Hit effect on ourselves
                if (game.player) {
                    createHitEffect(game.player.x, game.player.y, '#ff006e');
                }
            } else if (game.otherPlayers[data.targetId]) {
                game.otherPlayers[data.targetId].energy = data.energy;
                const target = game.otherPlayers[data.targetId];
                createHitEffect(target.x, target.y, '#ff006e');
            }
        });
        
        socket.on('playerDied', (data) => {
            if (data.playerId === game.myId) {
                game.player.x = data.respawn.x;
                game.player.y = data.respawn.y;
                game.player.velocityX = 0;
                game.player.velocityY = 0;
                game.player.energy = data.respawn.energy;
                game.player.dollarValue = data.respawn.dollarValue;
                game.player.invulnerable = true;
                game.player.invulnerableUntil = data.respawn.invulnerableUntil;
                game.player.killStreak = 0;
                game.player.bountyMultiplier = 1.0;
                game.pendingInputs = [];
            }
            
            if (data.moneyDrop) {
                game.money[data.moneyDrop.id] = data.moneyDrop;
                // Death explosion
                createHitEffect(data.moneyDrop.x, data.moneyDrop.y, '#FFD700');
            }
        });
        
        socket.on('moneyPickedUp', (data) => {
            const money = game.money[data.moneyId];
            if (money) {
                createHitEffect(money.x, money.y, '#FFD700');
            }
            delete game.money[data.moneyId];
            
            if (data.playerId === game.myId) {
                game.player.dollarValue = data.newDollarValue;
            }
        });
        
        socket.on('playerJoined', (player) => {
            if (player.id !== game.myId) {
                game.otherPlayers[player.id] = {
                    ...player,
                    renderX: player.x,
                    renderY: player.y
                };
            }
        });
        
        socket.on('playerLeft', (playerId) => {
            delete game.otherPlayers[playerId];
        });
        
        socket.on('pong', (timestamp) => {
            game.ping = Date.now() - timestamp;
        });
        
        setInterval(() => {
            if (game.connected) {
                socket.emit('ping', Date.now());
            }
        }, 2000);
        
        function updateConnectionStatus(text, className) {
            const status = document.getElementById('connectionStatus');
            status.textContent = text;
            status.className = className;
        }
        
        // ==================== SERVER RECONCILIATION ====================
        function reconcileServerState(serverPlayer) {
            if (!game.player) return;
            
            const errorX = serverPlayer.x - game.player.x;
            const errorY = serverPlayer.y - game.player.y;
            const errorDistance = Math.hypot(errorX, errorY);
            
            // Store for debugging
            game.player.predictionError = errorDistance;
            
            // Much more tolerant reconciliation for laggy connections
            if (errorDistance < 15) {
                // Small error - very gentle correction (works well up to 100ms ping)
                game.player.x += errorX * 0.05;
                game.player.y += errorY * 0.05;
            } else if (errorDistance < 50) {
                // Medium error - moderate correction
                game.player.x += errorX * 0.15;
                game.player.y += errorY * 0.15;
            } else if (errorDistance < 100) {
                // Large error - faster correction but still smooth
                game.player.x += errorX * 0.4;
                game.player.y += errorY * 0.4;
            } else {
                // Huge error - something is very wrong, snap to server
                console.warn('Massive position error:', errorDistance, 'snapping to server');
                game.player.x = serverPlayer.x;
                game.player.y = serverPlayer.y;
                game.player.velocityX = serverPlayer.velocityX;
                game.player.velocityY = serverPlayer.velocityY;
            }
            
            // Always trust server for these values
            game.player.energy = serverPlayer.energy;
            game.player.dollarValue = serverPlayer.dollarValue;
            game.player.invulnerable = serverPlayer.invulnerable;
            game.player.killStreak = serverPlayer.killStreak;
            game.player.bountyMultiplier = serverPlayer.bountyMultiplier;
            
            // Fix invulnerability - use server's timestamp directly
            if (serverPlayer.invulnerableUntil) {
                game.player.invulnerableUntil = serverPlayer.invulnerableUntil;
            }
            
            if (game.pendingInputs.length > 10) {
                game.pendingInputs = game.pendingInputs.slice(-5);
            }
        }
        
        // ==================== INPUT HANDLING ====================
        const keys = {};
        
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            game.mouse.x = e.clientX - rect.left;
            game.mouse.y = e.clientY - rect.top;
        });
        
        canvas.addEventListener('mousedown', () => {
            if (!game.player || !game.connected) return;
            game.charging.active = true;
            game.charging.startTime = Date.now();
            shoot(0);
        });
        
        canvas.addEventListener('mouseup', () => {
            if (!game.player || !game.connected || !game.charging.active) return;
            
            const chargeTime = Date.now() - game.charging.startTime;
            let chargeLevel = 0;
            
            if (chargeTime >= 1000) chargeLevel = 2;
            else if (chargeTime >= 500) chargeLevel = 1;
            
            if (chargeLevel > 0) {
                shoot(chargeLevel);
            }
            
            game.charging.active = false;
        });
        
        function shoot(chargeLevel) {
            if (!game.player || !game.config) return;
            
            const bulletTypes = game.config.BULLET.TYPES;
            let bulletType;
            
            switch(chargeLevel) {
                case 1: bulletType = bulletTypes.CHARGED1; break;
                case 2: bulletType = bulletTypes.CHARGED2; break;
                default: bulletType = bulletTypes.NORMAL;
            }
            
            if (game.player.energy < bulletType.energyCost) return;
            
            game.player.energy -= bulletType.energyCost;
            
            socket.emit('shoot', {
                chargeLevel: chargeLevel,
                timestamp: Date.now()
            });
        }
        
        function getChargeLevel() {
            if (!game.charging.active) return 0;
            const chargeTime = Date.now() - game.charging.startTime;
            if (chargeTime >= 1000) return 2;
            if (chargeTime >= 500) return 1;
            return 0;
        }
        
        // ==================== CLIENT PREDICTION ====================
        function processInput(deltaTime) {
            if (!game.player || !game.connected) return;
            
            const input = {
                sequence: game.inputSequence++,
                timestamp: Date.now(),
                up: keys['w'] || keys['arrowup'],
                down: keys['s'] || keys['arrowdown'],
                left: keys['a'] || keys['arrowleft'],
                right: keys['d'] || keys['arrowright'],
                boost: keys[' '],
                angle: Math.atan2(
                    game.mouse.y - (game.player.y - game.camera.y),
                    game.mouse.x - (game.player.x - game.camera.x)
                )
            };
            
            socket.emit('input', input);
            game.pendingInputs.push(input);
            applyInput(game.player, input, deltaTime);
            
            // Boost trail effect
            if (input.boost && game.player.energy > 0) {
                if (Math.random() < 0.3) {
                    createBoostTrail(game.player.x, game.player.y, game.player.angle);
                }
            }
        }
        
        function applyInput(player, input, deltaTime) {
            if (!game.config) return;
            
            let inputX = 0;
            let inputY = 0;
            
            if (input.up) inputY -= 1;
            if (input.down) inputY += 1;
            if (input.left) inputX -= 1;
            if (input.right) inputX += 1;
            
            if (inputX !== 0 && inputY !== 0) {
                const length = Math.hypot(inputX, inputY);
                inputX /= length;
                inputY /= length;
            }
            
            const accel = game.config.PLAYER.ACCELERATION * deltaTime;
            player.velocityX += inputX * accel;
            player.velocityY += inputY * accel;
            
            const momentum = Math.pow(game.config.PLAYER.MOMENTUM, deltaTime);
            player.velocityX *= momentum;
            player.velocityY *= momentum;
            
            const isBoosting = input.boost && player.energy > 0;
            if (isBoosting) {
                player.energy = Math.max(0, player.energy - game.config.PLAYER.ENERGY.BOOST_DRAIN * deltaTime);
            } else {
                player.energy = Math.min(
                    game.config.PLAYER.ENERGY.MAX,
                    player.energy + game.config.PLAYER.ENERGY.REGEN * deltaTime
                );
            }
            
            const maxVel = isBoosting ? game.config.PLAYER.MAX_BOOST_VELOCITY : game.config.PLAYER.MAX_VELOCITY;
            const speed = Math.hypot(player.velocityX, player.velocityY);
            if (speed > maxVel) {
                player.velocityX = (player.velocityX / speed) * maxVel;
                player.velocityY = (player.velocityY / speed) * maxVel;
            }
            
            player.x += player.velocityX * deltaTime;
            player.y += player.velocityY * deltaTime;
            player.angle = input.angle;
            
            // Don't update invulnerability here - let server handle it
            // The reconciliation will sync it from server state
        }
        
        // ==================== INTERPOLATION ====================
        function interpolateEntities(alpha) {
            // Slower interpolation for smoother movement on laggy connections
            const lerpFactor = Math.min(alpha, 0.25); // Cap at 25% to prevent jitter
            
            Object.values(game.otherPlayers).forEach(player => {
                if (player.prevX !== undefined) {
                    player.renderX += (player.x - player.renderX) * lerpFactor;
                    player.renderY += (player.y - player.renderY) * lerpFactor;
                } else {
                    player.renderX = player.x;
                    player.renderY = player.y;
                }
            });
            
            Object.values(game.bullets).forEach(bullet => {
                if (bullet.prevX !== undefined) {
                    // Bullets move fast, use slightly higher lerp
                    const bulletLerp = Math.min(alpha, 0.4);
                    bullet.renderX += (bullet.x - bullet.renderX) * bulletLerp;
                    bullet.renderY += (bullet.y - bullet.renderY) * bulletLerp;
                } else {
                    bullet.renderX = bullet.x;
                    bullet.renderY = bullet.y;
                }
            });
        }
        
        // ==================== RENDERING ====================
        function updateCamera() {
            if (!game.player || !game.config) return;
            
            game.camera.x = game.player.x - canvas.width / 2;
            game.camera.y = game.player.y - canvas.height / 2;
            
            game.camera.x = Math.max(0, Math.min(game.config.ARENA_WIDTH - canvas.width, game.camera.x));
            game.camera.y = Math.max(0, Math.min(game.config.ARENA_HEIGHT - canvas.height, game.camera.y));
        }
        
        function drawGrid() {
            if (!game.config) return;
            
            ctx.strokeStyle = 'rgba(0, 245, 255, 0.1)';
            ctx.lineWidth = 1;
            
            const gridSize = 50;
            const startX = Math.floor(game.camera.x / gridSize) * gridSize;
            const startY = Math.floor(game.camera.y / gridSize) * gridSize;
            
            for (let x = startX; x < game.camera.x + canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x - game.camera.x, 0);
                ctx.lineTo(x - game.camera.x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = startY; y < game.camera.y + canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y - game.camera.y);
                ctx.lineTo(canvas.width, y - game.camera.y);
                ctx.stroke();
            }
        }
        
        function drawBorders() {
            if (!game.config) return;
            
            ctx.strokeStyle = '#ff006e';
            ctx.lineWidth = 8;
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#ff006e';
            ctx.strokeRect(
                -game.camera.x,
                -game.camera.y,
                game.config.ARENA_WIDTH,
                game.config.ARENA_HEIGHT
            );
            ctx.shadowBlur = 0;
        }
        
        function drawPlayer(player, color = '#00f5ff', isLocalPlayer = false) {
            const screenX = player.x - game.camera.x;
            const screenY = player.y - game.camera.y;
            
            if (player.invulnerable && Math.floor(Date.now() / 100) % 2 === 0) {
                return;
            }
            
            // Bounty glow
            if (player.bountyMultiplier > 1.0) {
                let glowColor, glowSize;
                if (player.bountyMultiplier >= 3.0) {
                    glowColor = '#ff006e';
                    glowSize = 40;
                } else if (player.bountyMultiplier >= 2.0) {
                    glowColor = '#ffaa00';
                    glowSize = 35;
                } else {
                    glowColor = '#00f550';
                    glowSize = 30;
                }
                
                ctx.beginPath();
                ctx.arc(screenX, screenY, glowSize, 0, Math.PI * 2);
                ctx.strokeStyle = glowColor;
                ctx.lineWidth = 3;
                ctx.shadowBlur = 20;
                ctx.shadowColor = glowColor;
                ctx.globalAlpha = 0.6 + Math.sin(Date.now() / 200) * 0.2;
                ctx.stroke();
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1.0;
            }
            
            // Charging effect
            if (isLocalPlayer && game.charging.active) {
                const chargeLevel = getChargeLevel();
                let chargeColor = '#00f5ff';
                if (chargeLevel === 2) chargeColor = '#ff006e';
                else if (chargeLevel === 1) chargeColor = '#ffaa00';
                
                const pulseSize = 28 + Math.sin(Date.now() / 80) * 4;
                ctx.beginPath();
                ctx.arc(screenX, screenY, pulseSize, 0, Math.PI * 2);
                ctx.strokeStyle = chargeColor;
                ctx.lineWidth = 4;
                ctx.shadowBlur = 20;
                ctx.shadowColor = chargeColor;
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
            
            // Draw barrel with glow
            ctx.save();
            ctx.translate(screenX, screenY);
            ctx.rotate(player.angle);
            
            ctx.shadowBlur = 10;
            ctx.shadowColor = color;
            ctx.fillStyle = color;
            ctx.fillRect(10, -7.5, 35, 15);
            ctx.shadowBlur = 0;
            
            ctx.restore();
            
            // Draw body with glow
            ctx.beginPath();
            ctx.arc(screenX, screenY, 20, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.shadowBlur = 15;
            ctx.shadowColor = color;
            ctx.fill();
            ctx.shadowBlur = 0;
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw dollar value with better styling
            const gradient = ctx.createLinearGradient(screenX - 30, screenY - 35, screenX + 30, screenY - 35);
            gradient.addColorStop(0, '#FFD700');
            gradient.addColorStop(1, '#FFA500');
            
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.lineWidth = 4;
            ctx.strokeText(`$${player.dollarValue.toFixed(2)}`, screenX, screenY - 35);
            ctx.fillStyle = gradient;
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#FFD700';
            ctx.fillText(`$${player.dollarValue.toFixed(2)}`, screenX, screenY - 35);
            ctx.shadowBlur = 0;
        }
        
        function drawOtherPlayers() {
            Object.values(game.otherPlayers).forEach(player => {
                const renderPlayer = {
                    ...player,
                    x: player.renderX,
                    y: player.renderY
                };
                drawPlayer(renderPlayer, '#ff00ff', false);
            });
        }
        
        function drawBullets() {
            Object.values(game.bullets).forEach(bullet => {
                const screenX = bullet.renderX - game.camera.x;
                const screenY = bullet.renderY - game.camera.y;
                
                let color = '#00f5ff';
                if (bullet.chargeLevel === 2) color = '#ff006e';
                else if (bullet.chargeLevel === 1) color = '#ffaa00';
                
                ctx.beginPath();
                ctx.arc(screenX, screenY, bullet.radius, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.shadowBlur = 15;
                ctx.shadowColor = color;
                ctx.fill();
                ctx.shadowBlur = 0;
                
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }
        
        function drawMoney() {
            Object.values(game.money).forEach(money => {
                const screenX = money.x - game.camera.x;
                const screenY = money.y - game.camera.y;
                
                ctx.beginPath();
                ctx.arc(screenX, screenY, money.radius, 0, Math.PI * 2);
                
                const gradient = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, money.radius);
                gradient.addColorStop(0, '#FFD700');
                gradient.addColorStop(1, '#FFA500');
                ctx.fillStyle = gradient;
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#FFD700';
                ctx.fill();
                ctx.shadowBlur = 0;
                
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('$', screenX, screenY + 6);
            });
        }
        
        function drawParticles(deltaTime) {
            for (let i = particles.length - 1; i >= 0; i--) {
                if (!particles[i].update(deltaTime)) {
                    particles.splice(i, 1);
                } else {
                    particles[i].draw(game.camera);
                }
            }
        }
        
        function drawUI() {
            if (!game.player) return;
            
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            
            // Energy bar - glassmorphic style
            const barBg = ctx.createLinearGradient(20, 20, 20, 130);
            barBg.addColorStop(0, 'rgba(0, 0, 0, 0.6)');
            barBg.addColorStop(1, 'rgba(0, 0, 0, 0.4)');
            
            ctx.fillStyle = barBg;
            ctx.fillRect(15, 15, 120, 120);
            ctx.strokeStyle = 'rgba(0, 245, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.strokeRect(15, 15, 120, 120);
            
            ctx.fillStyle = '#00f5ff';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'left';
            ctx.shadowBlur = 5;
            ctx.shadowColor = '#00f5ff';
            ctx.fillText('ENERGY', 25, 35);
            ctx.shadowBlur = 0;
            
            const barX = 25;
            const barY = 45;
            const segmentWidth = 16;
            const segmentHeight = 8;
            const segmentSpacing = 2;
            const maxSegments = 20;
            const filledSegments = Math.floor(game.player.energy / 5);
            
            for (let i = 0; i < maxSegments; i++) {
                const x = barX + (i % 4) * (segmentWidth + segmentSpacing);
                const y = barY + Math.floor(i / 4) * (segmentHeight + segmentSpacing);
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.fillRect(x, y, segmentWidth, segmentHeight);
                
                if (i < filledSegments) {
                    let segColor;
                    if (game.player.energy >= 70) segColor = '#00f550';
                    else if (game.player.energy >= 30) segColor = '#ffaa00';
                    else segColor = '#ff006e';
                    
                    ctx.fillStyle = segColor;
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = segColor;
                    ctx.fillRect(x + 1, y + 1, segmentWidth - 2, segmentHeight - 2);
                    ctx.shadowBlur = 0;
                }
            }
            
            // Bounty info
            if (game.player.bountyMultiplier > 1.0) {
                const bountyBg = ctx.createLinearGradient(canvas.width - 180, 15, canvas.width - 180, 85);
                bountyBg.addColorStop(0, 'rgba(255, 0, 110, 0.3)');
                bountyBg.addColorStop(1, 'rgba(255, 0, 110, 0.1)');
                
                ctx.fillStyle = bountyBg;
                ctx.fillRect(canvas.width - 185, 15, 170, 70);
                ctx.strokeStyle = 'rgba(255, 0, 110, 0.5)';
                ctx.lineWidth = 2;
                ctx.strokeRect(canvas.width - 185, 15, 170, 70);
                
                ctx.fillStyle = '#ff006e';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'left';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ff006e';
                ctx.fillText(`BOUNTY: ${game.player.bountyMultiplier.toFixed(1)}x`, canvas.width - 175, 38);
                
                ctx.font = 'bold 14px Arial';
                ctx.fillText(`Kill Streak: ${game.player.killStreak}`, canvas.width - 175, 65);
                ctx.shadowBlur = 0;
            }
            
            // Debug info - bottom left
            const debugBg = ctx.createLinearGradient(10, canvas.height - 80, 10, canvas.height - 10);
            debugBg.addColorStop(0, 'rgba(0, 0, 0, 0.7)');
            debugBg.addColorStop(1, 'rgba(0, 0, 0, 0.5)');
            
            ctx.fillStyle = debugBg;
            ctx.fillRect(10, canvas.height - 95, 160, 85);
            ctx.strokeStyle = 'rgba(0, 245, 255, 0.2)';
            ctx.lineWidth = 2;
            ctx.strokeRect(10, canvas.height - 95, 160, 85);
            
            ctx.font = 'bold 13px monospace';
            ctx.textAlign = 'left';
            
            ctx.fillStyle = '#00f550';
            ctx.shadowBlur = 5;
            ctx.shadowColor = '#00f550';
            ctx.fillText(`FPS: ${Math.round(game.fps)}`, 20, canvas.height - 70);
            
            const pingColor = game.ping < 50 ? '#00f550' : game.ping < 100 ? '#ffaa00' : '#ff006e';
            ctx.fillStyle = pingColor;
            ctx.shadowColor = pingColor;
            ctx.fillText(`PING: ${game.ping}ms`, 20, canvas.height - 53);
            
            ctx.fillStyle = '#00f5ff';
            ctx.shadowColor = '#00f5ff';
            ctx.fillText(`TICK: ${game.serverTick}`, 20, canvas.height - 36);
            
            // Show prediction error for debugging
            if (game.player) {
                const predictionError = game.player.predictionError || 0;
                const errorColor = predictionError < 10 ? '#00f550' : predictionError < 30 ? '#ffaa00' : '#ff006e';
                ctx.fillStyle = errorColor;
                ctx.shadowColor = errorColor;
                ctx.fillText(`ERR: ${predictionError.toFixed(1)}`, 20, canvas.height - 19);
            }
            
            ctx.shadowBlur = 0;
            
            ctx.restore();
        }
        
        // ==================== MAIN LOOP ====================
        function gameLoop(currentTime) {
            frameCount++;
            if (currentTime - lastFpsUpdate >= 1000) {
                game.fps = frameCount;
                frameCount = 0;
                lastFpsUpdate = currentTime;
            }
            
            const deltaTime = Math.min((currentTime - lastFrameTime) / (1000 / 60), 3);
            lastFrameTime = currentTime;
            
            processInput(deltaTime);
            interpolateEntities(0.2);
            updateCamera();
            
            // Dark background with gradient
            const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            bgGradient.addColorStop(0, '#0a0e27');
            bgGradient.addColorStop(1, '#16213e');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            drawGrid();
            drawBorders();
            drawMoney();
            drawParticles(deltaTime);
            drawBullets();
            drawOtherPlayers();
            
            if (game.player) {
                drawPlayer(game.player, '#00f5ff', true);
            }
            
            drawUI();
            
            requestAnimationFrame(gameLoop);
        }
        
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>